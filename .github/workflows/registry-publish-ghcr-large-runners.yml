name: Build and Deploy OCI Image - GHCR
on:
  workflow_call:
    inputs:
      releaseTimeout:
        description: Timeout for the GoReleaser release command
        required: false
        default: 30m
        type: string
      pipeling:
        description: The name of the pipeline that triggered this workflow
        required: false
        default: steampipe
        type: string
      useCgo:
        description: Whether to use CGO for the build
        required: false
        default: false
        type: boolean

env:
  ORG: turbot
  CR: ghcr.io
  CR_PREFIX: turbot/${{ inputs.pipeling }}/plugins
  CONFIG_SCHEMA_VERSION: "2020-11-18"
  ORAS_VERSION: 1.3.0
  GOLANG_CROSS_VERSION: v1.24

jobs:
  build-deploy:
    runs-on:
      group: large-runners
    permissions:
      contents: read
      packages: write
    steps:
      - name: Output pipeling name
        run: |
          echo "Pipeling name: ${{ inputs.pipeling }}"
          echo "PIPELING_NAME=${{ inputs.pipeling }}" >> $GITHUB_ENV

      - name: Checkout
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
        with:
          path: ${{ inputs.pipeling }}-plugin
          fetch-depth: 0

      # Setup Env
      - name: Set environment variables
        run: |
          plugin_name=$(echo $GITHUB_REPOSITORY | cut -d'-' -f 3)
          echo $plugin_name
          echo "PLUGIN_NAME=${plugin_name}" >> $GITHUB_ENV

      # Exit early if we don't need to build
      - name: Exit if goreleaser file is missing
        run: |
          cd ${{ inputs.pipeling }}-plugin
          test -f .goreleaser.yml

      - name: Get latest version tag
        run: |
          cd ${{ inputs.pipeling }}-plugin
          echo "VERSION=${GITHUB_REF#refs/*/}" >> $GITHUB_ENV

      - name: Get latest trimmed version tag
        run: |
          echo $VERSION
          trim=${VERSION#"v"}
          echo $trim
          echo "VERSION=${trim}" >> $GITHUB_ENV

      - name: Validate Version String (only accept prod & rc)
        run: |-
          if [[ $VERSION =~ ^[0-9]+\.[0-9]+\.[0-9]+(-rc\.[0-9]+)?$ ]]; then
            echo "Version OK: $VERSION"
          else
            echo "Invalid version: $VERSION"
            exit 1
          fi

      - name: Ensure Version Does Not Exist
        run: |-
          URL=https://$CR/v2/$CR_PREFIX/$ORG/$PLUGIN_NAME/tags/list
          IDX=$(curl -L -H "Authorization: Bearer $(base64 <<< $GITHUB_TOKEN)" $URL | jq ".tags | index(\"$VERSION\")")
          if [ $IDX == "null" ]; then
            echo "OK - Version does not exist: $VERSION"
          else
            echo "Version already exists: $VERSION"
            exit 1
          fi

      # Setup go & build
      - name: Set up Go
        uses: actions/setup-go@19bb51245e9c80abacb2e91cc42b33fa478b8639 # v4.2.1
        with:
          go-version: 1.24

      - name: Clean temp directory before compression
        run: |
          echo "Cleaning temporary directories to ensure GoReleaser has sufficient space..."
          echo ""
          echo "Before cleanup:"
          df -h /tmp 2>/dev/null || df -h /var/tmp 2>/dev/null || echo "Cannot access /tmp"
          echo ""
          # Remove old temp files (keep system ones)
          sudo rm -rf /tmp/goreleaser* 2>/dev/null || true
          sudo rm -rf /tmp/go-build* 2>/dev/null || true
          sudo rm -rf /tmp/tmp* 2>/dev/null || true
          echo "Cleaned up old temporary files"
          echo ""
          echo "After cleanup:"
          df -h /tmp 2>/dev/null || df -h /var/tmp 2>/dev/null || echo "Cannot access /tmp"

      - name: Run GoReleaser (steampipe)
        if: ${{ inputs.useCgo == false || inputs.useCgo == 'false' }} 
        uses: goreleaser/goreleaser-action@v5  # Latest version
        with:
          workdir: ${{ inputs.pipeling }}-plugin
          version: latest
          args: release --clean --skip=publish --timeout=${{ inputs.releaseTimeout }}
        env:
          GORELEASER_PARALLELISM: 1

      - name: Log GoReleaser version after build
        continue-on-error: true
        run: |
          which goreleaser || echo "goreleaser not in PATH"
          goreleaser --version 2>/dev/null || echo "Could not get goreleaser version"

      - name: Run GoReleaser (tailpipe)
        if: ${{ inputs.useCgo == true || inputs.useCgo == 'true' }}
        run: |-
          cd ${{ inputs.pipeling }}-plugin
          docker run \
            --rm \
            -e CGO_ENABLED=1 \
            -v /var/run/docker.sock:/var/run/docker.sock \
            -v $PWD:/go/src/plugin \
            -w /go/src/plugin \
            ghcr.io/goreleaser/goreleaser-cross:${GOLANG_CROSS_VERSION} \
            release --clean --skip=publish --skip=validate --timeout=${{ inputs.releaseTimeout }}

      - name: List Build Artifacts
        run: |
          cd ${{ inputs.pipeling }}-plugin
          ls -laR ./dist

      # Copy artifacts into working dir
      - name: Copy artifacts, docs and config to working dir (steampipe)
        # run only if inputs.pipeling = steampipe
        if: ${{ env.PIPELING_NAME == 'steampipe' }}
        run: |
          cp ./${{ inputs.pipeling }}-plugin/dist/*.gz .
          cp -R ./${{ inputs.pipeling }}-plugin/docs .
          cp -R ./${{ inputs.pipeling }}-plugin/config .
          ls -al

      # Copy artifacts into working dir
      - name: Copy artifacts and docs to working dir (tailpipe)
        # run only if inputs.pipeling = tailpipe
        if: ${{ env.PIPELING_NAME == 'tailpipe' }}
        run: |
          cp ./${{ inputs.pipeling }}-plugin/dist/*.gz .
          cp -R ./${{ inputs.pipeling }}-plugin/docs .
          ls -al

      # Create files for registry
      - name: Create config file
        run: |-
          JSON_STRING=$( jq -n \
                    --arg name "$PLUGIN_NAME" \
                    --arg organization "$ORG" \
                    --arg version "$VERSION" \
                    --arg schemaVersion "$CONFIG_SCHEMA_VERSION" \
                    '{schemaVersion: $schemaVersion, plugin: { name: $name, organization: $organization, version: $version} }' )
          echo $JSON_STRING > config.json

      - name: Create annotations file
        run: |-
          JSON_STRING=$( jq -n \
                   --arg title "$PLUGIN_NAME" \
                   --arg desc "$ORG" \
                   --arg version "$VERSION" \
                   --arg timestamp "$(date +%FT%T%z | sed 's/\([0-9][0-9]\)\([0-9][0-9]\)$/\1:\2/')" \
                   --arg repo "$GITHUB_SERVER_URL/$GITHUB_REPOSITORY" \
                   --arg commit "$GITHUB_SHA" \
                   --arg vendor "Turbot HQ, Inc." \
                 '{
                   "$manifest": {
                       "org.opencontainers.image.title": $title,
                       "org.opencontainers.image.description": $desc,
                       "org.opencontainers.image.version": $version,
                       "org.opencontainers.image.created": $timestamp,
                       "org.opencontainers.image.source": $repo,
                       "org.opencontainers.image.revision": $commit,
                       "org.opencontainers.image.vendor":  $vendor
                   }
                 }' )
           echo $JSON_STRING > annotations.json

      - name: View annotations
        run: |
          cat annotations.json

      - name: View README
        run: |
          cd ${{ inputs.pipeling }}-plugin
          cat README.md

      # Upload build artifacts for inspection
      - name: Upload build artifacts
        if: always()  # Run even if previous steps fail
        uses: actions/upload-artifact@v4
        with:
          name: plugin-archives-${{ env.VERSION }}
          path: |
            ${{ inputs.pipeling }}-plugin-*.gz
          retention-days: 7
          compression-level: 0  # Don't compress, we want raw files

      # Validate plugin archives (gzip integrity)
      - name: Validate plugin archives (gzip integrity)
        continue-on-error: true
        run: |
          echo "Validating plugin archives..."
          echo ""
          
          required_files=(
            "${{ inputs.pipeling }}-plugin-${PLUGIN_NAME}_darwin_amd64.gz"
            "${{ inputs.pipeling }}-plugin-${PLUGIN_NAME}_darwin_arm64.gz"
            "${{ inputs.pipeling }}-plugin-${PLUGIN_NAME}_linux_amd64.gz"
            "${{ inputs.pipeling }}-plugin-${PLUGIN_NAME}_linux_arm64.gz"
          )
          
          missing_files=0
          corrupted_files=0
          
          for file in "${required_files[@]}"; do
            echo "Checking: $file"
            if [ ! -f "$file" ]; then
              echo "⚠️  SKIP: File not found (may be partial build): $file"
              missing_files=$((missing_files + 1))
              echo ""
              continue
            fi
            
            # Verify file integrity with gzip test
            if gzip -t "$file" 2>/dev/null; then
              # portable size (Linux/macOS)
              size=$(stat -c%s "$file" 2>/dev/null || stat -f%z "$file" 2>/dev/null)
              size_mb=$((size / 1048576))
              echo "✓ $file (${size_mb} MB) – gzip OK"
            else
              echo "❌ ERROR: Corrupted file: $file"
              corrupted_files=$((corrupted_files + 1))
            fi
            echo ""
          done
          
          echo "Summary:"
          echo "  Missing files : $missing_files"
          echo "  Corrupted files: $corrupted_files"
          echo ""
          
          if [ $corrupted_files -gt 0 ]; then
            echo "FATAL: Validation failed!"
            echo ""
            echo "Current directory contents:"
            ls -lh ${{ inputs.pipeling }}-plugin-*.gz 2>/dev/null || echo "  No .gz files found in working directory"
            echo ""
            exit 1
          fi
          
          echo "✓ All available archives passed gzip integrity check"

      # Smoke test Linux plugin binaries (if they exist)
      - name: Smoke test Linux plugin binaries
        continue-on-error: true
        run: |
          echo "Running Linux plugin smoke tests..."
          echo ""
          
          linux_files=(
            "${{ inputs.pipeling }}-plugin-${PLUGIN_NAME}_linux_amd64.gz"
            "${{ inputs.pipeling }}-plugin-${PLUGIN_NAME}_linux_arm64.gz"
          )
          
          for gz in "${linux_files[@]}"; do
            if [ ! -f "$gz" ]; then
              echo "⚠️  Skipping: $gz (not found – may be partial build)"
              continue
            fi
            
            echo ""
            echo "=== Testing: $gz ==="
            
            # Decompress into a temp file
            tmp_bin="plugin-test-binary-$$"
            rm -f "$tmp_bin"
            
            if ! gzip -dc "$gz" > "$tmp_bin"; then
              echo "❌ Failed to decompress $gz"
              rm -f "$tmp_bin"
              continue
            fi
            
            chmod +x "$tmp_bin" 2>/dev/null || true
            
            echo "file(1) output:"
            file "$tmp_bin" 2>/dev/null || echo "  (file command not available)"
            
            echo "Trying to run plugin binary (best-effort)..."
            # Try common version flags
            if ./"$tmp_bin" --version 2>/dev/null || ./"$tmp_bin" -version 2>/dev/null || ./"$tmp_bin" -v 2>/dev/null || ./"$tmp_bin" version 2>/dev/null; then
              echo "✓ Binary executed successfully"
            else
              echo "⚠️  Binary did not respond to common version flags, but decompressed successfully"
            fi
            
            rm -f "$tmp_bin"
            echo "✓ Smoke test completed for: $gz"
          done

      # # OLD Validate build artifacts - COMMENTED OUT FOR REPLACEMENT
      # - name: Validate all plugin archives exist and are valid
      #   run: |
      #     echo "Validating plugin archives..."
      #     echo ""

      #     required_files=(
      #       "${{ inputs.pipeling }}-plugin-${PLUGIN_NAME}_darwin_amd64.gz"
      #       "${{ inputs.pipeling }}-plugin-${PLUGIN_NAME}_darwin_arm64.gz"
      #       "${{ inputs.pipeling }}-plugin-${PLUGIN_NAME}_linux_amd64.gz"
      #       "${{ inputs.pipeling }}-plugin-${PLUGIN_NAME}_linux_arm64.gz"
      #     )

      #     missing_files=0
      #     corrupted_files=0

      #     for file in "${required_files[@]}"; do
      #       if [ ! -f "$file" ]; then
      #         echo "❌ ERROR: Missing file: $file"
      #         missing_files=$((missing_files + 1))
      #       else
      #         # Verify file integrity with gzip test
      #         if gzip -t "$file" 2>/dev/null; then
      #           size=$(stat -c%s "$file" 2>/dev/null || stat -f%z "$file" 2>/dev/null)
      #           size_mb=$((size / 1048576))
      #           echo "✓ $file ($size_mb MB)"
      #         else
      #           echo "❌ ERROR: Corrupted file: $file"
      #           corrupted_files=$((corrupted_files + 1))
      #         fi
      #       fi
      #     done

      #     echo ""
      #     if [ $missing_files -gt 0 ] || [ $corrupted_files -gt 0 ]; then
      #       echo "FATAL: Validation failed!"
      #       echo "  Missing files: $missing_files"
      #       echo "  Corrupted files: $corrupted_files"
      #       echo ""
      #       echo "Current directory contents:"
      #       ls -lh ${{ inputs.pipeling }}-plugin-*.gz 2>/dev/null || echo "  No .gz files found in working directory"
      #       echo ""
      #       echo "Source directory (dist/):"
      #       ls -lh ${{ inputs.pipeling }}-plugin/dist/*.gz 2>/dev/null || echo "  No .gz files found in dist/"
      #       exit 1
      #     fi

      #     echo ""
      #     echo "✓ All required archives validated successfully"

      # Setup ORAS
      - name: Install specific version of ORAS
        run: |
          curl -LO https://github.com/oras-project/oras/releases/download/v${ORAS_VERSION}/oras_${ORAS_VERSION}_linux_amd64.tar.gz
          sudo tar xzf oras_${ORAS_VERSION}_linux_amd64.tar.gz -C /usr/local/bin oras
          oras version

      # Log ORAS and environment info
      - name: Log ORAS execution environment
        continue-on-error: true
        run: |
          echo "=== ORAS EXECUTION ENVIRONMENT ==="
          echo ""
          echo "ORAS Version:"
          oras version
          echo ""
          echo "Environment Variables:"
          echo "  ORAS_VERSION: $ORAS_VERSION"
          echo "  CR: $CR"
          echo "  CR_PREFIX: $CR_PREFIX"
          echo "  PLUGIN_NAME: $PLUGIN_NAME"
          echo "  VERSION: $VERSION"
          echo ""
          echo "Pre-push file sizes:"
          ls -lh ${{ inputs.pipeling }}-plugin-*.gz 2>/dev/null | awk '{print "  " $9 ": " $5}'

      # Login to GHCR
      - name: Log in to the Container registry
        uses: docker/login-action@465a07811f14bebb1938fbed4728c6a1ff8901fc # v2.2.0
        with:
          registry: ${{ env.CR }}
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # Publish to GHCR
      - name: Push to the container registry (tailpipe)
        # run only if inputs.pipeling = tailpipe
        if: ${{ env.PIPELING_NAME == 'tailpipe' }}
        run: |
          REF="$CR/$CR_PREFIX/$ORG/$PLUGIN_NAME:$VERSION"
          LATEST_REF="$CR/$CR_PREFIX/$ORG/$PLUGIN_NAME:latest"
          oras push $REF \
            --config config.json:application/vnd.turbot.${{ inputs.pipeling }}.config.v1+json \
            --annotation-file annotations.json \
            ${{ inputs.pipeling }}-plugin-${PLUGIN_NAME}_darwin_amd64.gz:application/vnd.turbot.${{ inputs.pipeling }}.plugin.darwin-amd64.layer.v1+gzip \
            ${{ inputs.pipeling }}-plugin-${PLUGIN_NAME}_darwin_arm64.gz:application/vnd.turbot.${{ inputs.pipeling }}.plugin.darwin-arm64.layer.v1+gzip \
            ${{ inputs.pipeling }}-plugin-${PLUGIN_NAME}_linux_amd64.gz:application/vnd.turbot.${{ inputs.pipeling }}.plugin.linux-amd64.layer.v1+gzip \
            ${{ inputs.pipeling }}-plugin-${PLUGIN_NAME}_linux_arm64.gz:application/vnd.turbot.${{ inputs.pipeling }}.plugin.linux-arm64.layer.v1+gzip \
            docs:application/vnd.turbot.${{ inputs.pipeling }}.plugin.docs.layer.v1+tar

          # tag the image with the GitHub Run ID for traceability
          oras tag $REF $GITHUB_RUN_ID

          # check if the version is NOT an rc version before tagging as latest
          if [[ $VERSION =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "Tagging as latest: $LATEST_REF"
            oras tag $REF $LATEST_REF
          else
            echo "Skipping latest tag for rc version: $VERSION"
          fi

      # Publish to GHCR
      - name: Push to the container registry (steampipe)
        # run only if inputs.pipeling = steampipe
        if: ${{ env.PIPELING_NAME == 'steampipe' }}
        run: |
          echo "=== ORAS PUSH EXECUTION WITH VERBOSE LOGGING ==="
          echo ""
          
          REF="$CR/$CR_PREFIX/$ORG/$PLUGIN_NAME:$VERSION"
          LATEST_REF="$CR/$CR_PREFIX/$ORG/$PLUGIN_NAME:latest"
          
          echo "Pushing to: $REF"
          echo ""
          echo "Files being pushed:"
          ls -lh ${{ inputs.pipeling }}-plugin-*.gz 2>/dev/null | awk '{print "  " $9 ": " $5}'
          echo ""
          
          # Build ORAS push command dynamically to only include files that exist
          echo "Starting ORAS push operation..."
          echo ""
          
          ORAS_CMD="oras push $REF --config config.json:application/vnd.turbot.${{ inputs.pipeling }}.config.v1+json --annotation-file annotations.json"
          
          echo "Adding plugin archives to ORAS command..."
          
          # Add plugin archives only if they exist
          if [ -f "${{ inputs.pipeling }}-plugin-${PLUGIN_NAME}_darwin_amd64.gz" ]; then
            echo "  ✓ Including darwin_amd64.gz"
            ORAS_CMD="$ORAS_CMD ${{ inputs.pipeling }}-plugin-${PLUGIN_NAME}_darwin_amd64.gz:application/vnd.turbot.${{ inputs.pipeling }}.plugin.darwin-amd64.layer.v1+gzip"
          else
            echo "  ⚠️  Skipping darwin_amd64.gz (not found)"
          fi
          
          if [ -f "${{ inputs.pipeling }}-plugin-${PLUGIN_NAME}_darwin_arm64.gz" ]; then
            echo "  ✓ Including darwin_arm64.gz"
            ORAS_CMD="$ORAS_CMD ${{ inputs.pipeling }}-plugin-${PLUGIN_NAME}_darwin_arm64.gz:application/vnd.turbot.${{ inputs.pipeling }}.plugin.darwin-arm64.layer.v1+gzip"
          else
            echo "  ⚠️  Skipping darwin_arm64.gz (not found)"
          fi
          
          # Only check for Linux builds if they exist (they shouldn't in darwin-only builds)
          if [ -f "${{ inputs.pipeling }}-plugin-${PLUGIN_NAME}_linux_amd64.gz" ]; then
            echo "  ✓ Including linux_amd64.gz"
            ORAS_CMD="$ORAS_CMD ${{ inputs.pipeling }}-plugin-${PLUGIN_NAME}_linux_amd64.gz:application/vnd.turbot.${{ inputs.pipeling }}.plugin.linux-amd64.layer.v1+gzip"
          else
            echo "  ℹ️  Skipping linux_amd64.gz (not built)"
          fi
          
          if [ -f "${{ inputs.pipeling }}-plugin-${PLUGIN_NAME}_linux_arm64.gz" ]; then
            echo "  ✓ Including linux_arm64.gz"
            ORAS_CMD="$ORAS_CMD ${{ inputs.pipeling }}-plugin-${PLUGIN_NAME}_linux_arm64.gz:application/vnd.turbot.${{ inputs.pipeling }}.plugin.linux-arm64.layer.v1+gzip"
          else
            echo "  ℹ️  Skipping linux_arm64.gz (not built)"
          fi
          
          # Add docs and config (always exist)
          echo "  ✓ Including docs and config"
          ORAS_CMD="$ORAS_CMD docs:application/vnd.turbot.${{ inputs.pipeling }}.plugin.docs.layer.v1+tar config:application/vnd.turbot.${{ inputs.pipeling }}.plugin.spc.layer.v1+tar"
          
          echo ""
          echo "Executing ORAS push command..."
          echo ""
          
          if eval "$ORAS_CMD"; then
            echo "✓ ORAS push completed successfully"
          else
            echo "❌ ORAS push failed - see output above for details"
            exit 1
          fi
          
          echo ""
          
          # tag the image with the GitHub Run ID for traceability
          echo "Tagging with Run ID: $GITHUB_RUN_ID"
          if oras tag $REF $GITHUB_RUN_ID; then
            echo "✓ Run ID tag created"
          else
            echo "⚠ Warning: Failed to tag with Run ID"
          fi

          # check if the version is NOT an rc version before tagging as latest
          if [[ $VERSION =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "Tagging as latest: $LATEST_REF"
            if oras tag $REF $LATEST_REF; then
              echo "✓ Latest tag created"
            else
              echo "⚠ Warning: Failed to create latest tag"
            fi
          else
            echo "Skipping latest tag for rc version: $VERSION"
          fi
